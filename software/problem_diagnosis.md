# DC模块死锁问题完整诊断

## 问题现象
- ✅ 1-5 kHz：工作正常
- ❌ 10 kHz：运行3秒后死锁，接收约28 KB数据
- ❌ ≥20 kHz：快速死锁

## 完整因果链

```
┌─────────────────────────────────────────────────────────────────┐
│ 根本原因1：Windows CDC驱动性能限制（设计特性，非BUG）           │
│ - 轮询间隔：1-16ms                                              │
│ - 实际吞吐：10-15 KB/s（虽然USB理论60 MB/s）                   │
└─────────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│ 触发条件：采样率 ≥ 10 kHz（10 KB/s）                           │
│ - FPGA生产速率：10 KB/s（稳定）                                │
│ - USB消费速率：10-15 KB/s（突发性，不稳定）                    │
│ - 短期内：生产 > 消费 → 缓冲区逐渐积累                         │
└─────────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│ 缓冲区填满过程                                                   │
│ 0s:  缓冲区空，传输正常                                          │
│ 1s:  积累约 10 KB                                               │
│ 2s:  积累约 20 KB                                               │
│ 3s:  积累约 28 KB → 缓冲区满！                                  │
│                                                                  │
│ 缓冲区链：                                                       │
│ - EP2_IN FIFO: 4 KB                                             │
│ - Windows Driver Buffer: ~24 KB                                 │
│ - 总计：28 KB                                                   │
└─────────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│ 根本原因2：Handler状态机BUG（代码缺陷，必须修复）              │
│                                                                  │
│ digital_capture_handler.v:206-220                               │
│                                                                  │
│ UP_IDLE: begin                                                  │
│     if (new_sample_flag) begin                                  │
│         upload_req <= 1'b1;                                     │
│         if (upload_ready) begin  ← 当FIFO满时，upload_ready=0  │
│             upload_valid <= 1'b1;                               │
│             upload_state <= UP_SEND;                            │
│         end                                                     │
│         // ❌ 没有else分支！状态机卡在UP_IDLE                   │
│     end                                                         │
│ end                                                             │
└─────────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│ 死锁状态                                                         │
│ - upload_ready = 0（FIFO满）                                    │
│ - new_sample_flag = 1（有新样本）                               │
│ - upload_state = UP_IDLE（卡住）                                │
│ - FPGA停止上传数据                                              │
│ - Python脚本停止接收数据                                        │
│ - 必须复位FPGA才能恢复                                          │
└─────────────────────────────────────────────────────────────────┘
```

## 责任归属

### ❌ Handler文件（digital_capture_handler.v）
- **责任**：代码缺陷
- **问题**：状态机缺少FIFO满的处理逻辑
- **严重性**：致命（导致死锁）
- **修复**：必须修复

### ✅ USB CDC代码（usb_cdc.v等）
- **责任**：无问题
- **状态**：代码正确，配置最优
- **修复**：不需要修改

### ⚠️ Windows CDC驱动
- **责任**：不是BUG，是设计特性
- **问题**：CDC协议固有的性能限制
- **严重性**：限制性能，但不会导致死锁
- **修复**：无法修改（操作系统内置）

## 解决方案优先级

### 🔴 优先级1：修复Handler状态机（必须）
```verilog
// 在 digital_capture_handler.v:206-220 添加：
if (upload_ready) begin
    upload_valid <= 1'b1;
    upload_state <= UP_SEND;
end else begin
    // ✅ FIFO满时，丢弃样本，防止死锁
    new_sample_flag <= 1'b0;
end
```

**效果**：
- ✅ 彻底解决死锁问题
- ✅ 支持更高采样率（虽然会丢失部分样本）
- ✅ 工作量小（只需修改3行代码）

### 🟡 优先级2：限制采样率（临时方案）
- 限制采样率 ≤ 5 kHz
- 不修改任何代码
- 完全稳定，无数据丢失
- 但限制了功能

### 🟢 优先级3：替换为USB Bulk（长期方案）
- 完全重写USB部分
- 需要自定义Windows驱动
- 可达到10-30 MB/s吞吐率
- 工作量巨大

## 类比理解

想象一个水管系统：

```
水源（FPGA）   →   水管（USB）   →   水龙头（Windows驱动）   →   水桶（Python）
10 L/秒          60,000 L/秒       10 L/秒（限流阀）          接收水

问题：
1. 水管很粗（60,000 L/秒 = USB带宽）← 没问题
2. 水龙头限流（10 L/秒 = CDC限制）  ← 设计特性
3. 水源和限流阀速率接近 → 中间积水  ← 正常现象
4. 水源没有溢出阀 → 水管爆裂         ← BUG！必须修复
```

**修复方法**：给水源加溢出阀（状态机添加丢弃逻辑）

## 结论

**三个组件的问题类型完全不同**：

| 组件 | 问题性质 | 解决方法 |
|------|---------|---------|
| Handler | 🔴 **代码BUG** | **必须修复** |
| USB代码 | ✅ 正常 | 不需要修改 |
| Windows驱动 | ⚠️ 设计限制 | 无法修改 |

**立即行动**：修复Handler状态机，这是唯一必须做的事情。
