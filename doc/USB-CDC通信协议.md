# USB-CDC通信协议

| 字段            | 字节数  |
| --------------- | ------- |
| 帧头            | 2       |
| 功能码/数据来源 | 1       |
| 数据长度        | 2       |
| 数据体          | 0-65535 |
| 校验和          | 1       |


## 帧头

指令为0xAA55。上传的数据为0xAA44。

## 功能码

| 功能码 | 功能描述             | 完成情况 |
| ------ | -------------------- | -------- |
| 0x01   |                      |
| 0x02   | **发送I2C_NO_ADDR**  | ✅        |
| 0x03   | **接收I2C_NO_ADDR**  | ✅        |
| 0x04   | **配置I2C（BOTH）**  | ✅        |
| 0x05   | **发送I2C数据**      | ✅        |
| 0x06   | **接收I2C数据**      | ✅        |
| 0x07   | **配置UART**         | ✅        |
| 0x08   | **发送UART数据**     | ✅        |
| 0x09   | **接收UART数据**     | ✅        |
| 0x0A   | **数字信号测量**     | ✅        |
| 0x0B   | **数字逻辑捕获启动** | ✅        |
| 0x0C   | **数字逻辑捕获停止** | ✅        |
| 0x11   | **SPI读写操作**      | ✅        |
| 0x20   | **1-Wire复位**       | ✅        |
| 0x21   | **1-Wire写字节**     | ✅        |
| 0x22   | **1-Wire读字节**     | ✅        |
| 0x23   | **1-Wire写读操作**   | ✅        |
| 0x27   | **配置CAN总线**      | ✅        |
| 0x28   | **发送CAN数据帧**    | ✅        |
| 0x29   | **读取CAN接收数据**  | ✅        |
| 0xFC   | **自定义波形上传**   | ✅        |
| 0xFD   | **配置DAC输出**      | ✅        |
| 0xFE   | **配置PWM输出**      | ✅        |
| 0xFF   | **心跳测试**         | ✅        |

## 数据长度

- **值**: 16位无符号整数，例如 `0x000A` 表示数据体有10个字节。
- **字节序**: 大端模式（Big-Endian）**，即高字节在前。`0x000A` 发送时就是 `0x00` 先发，`0x0A` 后发。

## 数据体

### SPI读写操作 (功能码 0x11)
| 字段     | 字节数    | 说明                       |
| -------- | --------- | -------------------------- |
| 写长度   | 1         | 要发送的数据字节数 (0-255) |
| 读长度   | 1         | 要读取的数据字节数 (0-255) |
| 发送数据 | write_len | 要发送的数据字节           |

**操作说明**：
- 该功能支持同时进行写和读操作
- 先发送write_len个字节的数据到SPI从机
- 然后从SPI从机读取read_len个字节的数据
- 如果write_len=0且read_len>0，只进行读取操作
- 如果read_len=0，只进行写入操作，不上传接收数据

**响应数据格式**：
- 帧头：0xAA44（上传数据标识）
- 数据来源：0x03（SPI模块）
- 数据长度：read_len
- 数据体：实际读取到的read_len个字节数据

**示例1**：写2字节，读1字节
```
发送: AA 55 11 00 04 02 01 AB CD 90
      ^^^^帧头 ^^功能码 ^^^^长度 ^^写2字节 ^^读1字节 ^^^^发送数据 ^^校验和
响应: AA 44 03 00 01 EF yy (yy为校验和)
      ^^^^上传帧头 ^^SPI源 ^^^^长度1 ^^读取的数据
```

**示例2**：只读2字节
```
发送: AA 55 11 00 02 00 02 15
      ^^^^帧头 ^^功能码 ^^^^长度 ^^写0字节 ^^读2字节 ^^校验和
响应: AA 44 03 00 02 12 34 yy (yy为校验和)
```

**示例3**：只写1字节（不读取）
```
发送: AA 55 11 00 03 01 00 AB C0
      ^^^^帧头 ^^功能码 ^^^^长度 ^^写1字节 ^^读0字节 ^^发送数据 ^^校验和
响应: 无（read_len=0，不上传数据）
```

**示例4**：写1字节，读1字节（回环测试）
```
发送: AA 55 11 00 03 01 01 AB C1
      ^^^^帧头 ^^功能码 ^^^^长度 ^^写1字节 ^^读1字节 ^^发送数据 ^^校验和
响应: AA 44 03 00 01 AB yy (如果MOSI-MISO短接，返回相同数据)
```

### I2C_NO_ADDR配置 (功能码 0x01)

### I2C_NO_ADDR发送 (功能码 0x02)

| 字段         | 描述                          | 值 (Hex)                          | 备注                     |
| ------------ | ----------------------------- | --------------------------------- | ------------------------ |
| 帧头         | 固定的指令帧头                | AA 55                             |                          |
| 功能码       | I2C发送                       | 0x05                              |                          |
| 数据长度     | **4个字节**的数据体           | **00 04**                         | **修改点**: 长度从6变为4 |
| 数据体[3:0]  | 要写入的数据                  | DE AD BE EF                       |                          |
| 校验和       | (05+00+04+DE+AD+BE+EF) & 0xFF | **41**                            |                          |
| **完整指令** |                               | **AA 55 05 00 04 DE AD BE EF 41** |                          |

### I2C_NO_ADDR接收 (功能码 0x03)

| 字段         | 描述                    | 值 (Hex)                | 备注                     |
| ------------ | ----------------------- | ----------------------- | ------------------------ |
| 帧头         | 固定的指令帧头          | AA 55                   |                          |
| 功能码       | I2C接收                 | 0x06                    |                          |
| 数据长度     | **2个字节**的数据体     | **00 02**               | **修改点**: 长度从4变为2 |
| 数据体[1:0]  | 要读取的长度            | 00 04                   |                          |
| 校验和       | (06+00+02+00+04) & 0xFF | **0C**                  |                          |
| **完整指令** |                         | AA 55 06 00 02 00 04 0C |                          |


### I2C配置 (功能码 0x04)
| 字段         | 描述                    | 值 (Hex)                   | 备注                                               |
| ------------ | ----------------------- | -------------------------- | -------------------------------------------------- |
| 帧头         | 固定的指令帧头          | AA 55                      |                                                    |
| 功能码       | I2C配置                 | 0x04                       |                                                    |
| 数据长度     | 2个字节的数据体         | 00 02                      |                                                    |
| 数据体       | 7位从机地址             | 50                         | 目标设备地址                                       |
| 数据体       | 时钟频率代码            | 03                         | 0x03 代表 400kHz（0代表50k，1代表100k，2代表200k） |
| 校验和       | (04+00+02+50+03) & 0xFF | 59                         |                                                    |
| **完整指令** |                         | AA 55 04 00 03 50 01 01 59 | 100kHz                                             |
| **0.0**      |                         | AA 55 04 00 03 50 01 02 5A | 400kHz                                             |

### I2C发送 (功能码 0x05)

| 字段         | 描述                                | 值 (Hex)                            | 备注                  |
| ------------ | ----------------------------------- | ----------------------------------- | --------------------- |
| 帧头         | 固定的指令帧头                      | AA 55                               |                       |
| 功能码       | I2C发送                             | 0x05                                |                       |
| 数据长度     | 6个字节的数据体                     | 00 06                               | 2字节地址 + 4字节数据 |
| 数据体[1:0]  | 寄存器地址                          | 00 3C                               |                       |
| 数据体[5:2]  | 要写入的数据                        | DE AD BE EF                         |                       |
| 校验和       | (05+00+06+00+3C+DE+AD+BE+EF) & 0xFF | 7F                                  |                       |
| **完整指令** |                                     | AA 55 05 00 06 00 3C DE AD BE EF 7F |                       |

### I2C接收 (功能码 0x06)
|              |                               |                               |                       |
| ------------ | ----------------------------- | ----------------------------- | --------------------- |
| 字段         | 描述                          | 值 (Hex)                      | 备注                  |
| 帧头         | 固定的指令帧头                | AA 55                         |                       |
| 功能码       | I2C接收                       | 0x06                          |                       |
| 数据长度     | 4个字节的数据体               | 00 04                         | 2字节地址 + 2字节长度 |
| 数据体[1:0]  | 寄存器地址                    | 00 3C                         |                       |
| 数据体[3:2]  | 要读取的长度                  | 00 04                         | 读取4个字节           |
| 校验和       | (06+00+04+00+3C+00+04) & 0xFF | 4A                            |                       |
| **完整指令** |                               | AA 55 06 00 04 00 3C 00 04 4A |                       |

### I2C从机配置地址（0x14）

AA 55 14 00 01 25 3A

能用

AA 55 15 00 04 02 02 11 22 50

AA 55 16 00 02 00 02 [CS]

这俩都不能用 

设想是00 01 02 03四个寄存器
CDC 往 02 03 预先写入数据 CDC 可以读取 00 01 的数据

I2C 接收到的数据存在 00 01 读取的时候返回02 03 的数据

**写不出来喵 现在只能实现I2C一方面的功能 寄存器问题，没办法作为一个调试器只能是一个被调试器的功能。**

### UART配置 (功能码 0x07) 

| 字段   | 字节数 | 说明                            |
| ------ | ------ | ------------------------------- |
| 波特率 | 4      | 32位整数，如9600, 115200等      |
| 数据位 | 1      | 5, 6, 7, 8                      |
| 停止位 | 1      | 1, 1.5, 2                       |
| 校验位 | 1      | 0: 无校验, 1: 奇校验, 2: 偶校验 |

### UART发送 (功能码 0x08)
数据体为要发送的原始数据字节

### UART接收 (功能码 0x09)
数据体为空，响应为接收到的数据字节

### 数字信号测量 (功能码 0x0A)
| 字段     | 字节数 | 说明                                               |
| -------- | ------ | -------------------------------------------------- |
| 通道掩码 | 1      | 8位掩码，每位对应一个测量通道，1表示启用该通道测量 |

**响应数据格式** (每个启用的通道返回9字节数据)：
| 字段       | 字节数 | 说明                             |
| ---------- | ------ | -------------------------------- |
| 通道号     | 1      | 当前数据对应的通道号 (0-7)       |
| 高电平时间 | 2      | 16位无符号整数，单位：时钟周期   |
| 低电平时间 | 2      | 16位无符号整数，单位：时钟周期   |
| 周期时间   | 2      | 16位无符号整数，单位：时钟周期   |
| 占空比     | 2      | 16位无符号整数，单位：百分比×100 |

**示例**：
- 启用通道0和2：通道掩码 = 0x05 (二进制: 00000101)
- 返回数据：通道0的9字节数据 + 通道2的9字节数据，共18字节

### 数字逻辑捕获启动 (功能码 0x0B)
| 字段           | 字节数 | 说明          |
| -------------- | ------ | ------------- |
| 采样分频高字节 | 1      | 分频系数高8位 |
| 采样分频低字节 | 1      | 分频系数低8位 |

**功能说明**：
- 启动 8 通道数字逻辑实时捕获
- 采样率 = 系统时钟频率 / 分频系数 (60MHz / divider)
- 捕获后的数据通过 USB 连续流式上传（直通模式，无协议封装）
- 每个采样周期产生 1 字节数据（8 通道状态）

**分频系数计算**：
```
divider = 60,000,000 / 目标采样率

示例：
- 1 MHz 采样: divider = 60
- 500 kHz 采样: divider = 120
- 100 kHz 采样: divider = 600
```

**数据格式**：
- 每字节对应一个采样时刻
- Bit[7:0] = [CH7, CH6, CH5, CH4, CH3, CH2, CH1, CH0]
- 1 = 高电平，0 = 低电平

**上传数据格式（直通模式）**：
- **无协议头**，直接输出原始采样字节流
- PC 端需要特殊处理，识别数据来源为 Digital Capture
- 数据源标识：0x0B（仅在系统内部使用）

**示例**：
```
发送: AA 55 0B 00 02 00 3C 9F
      ^^^^帧头 ^^功能码 ^^^^长度=2 ^^分频高 ^^分频低 ^^校验和

      divider = 0x003C = 60 → 1MHz 采样率

响应: 连续字节流（无帧头）
      AA 55 AA 55 FF 00 ...
      ^^  ^^  ^^  ^^  ^^  ^^
    采样1 2   3   4   5   6
```

**限制**：
- 最大采样率：1.2 MHz (divider = 50)
- 推荐采样率：≤ 1 MHz (稳定运行)
- 最小分频系数：50
- 最大分频系数：65535

**注意事项**：
- ⚠️ 启动采集后，USB 带宽将被占用
- ⚠️ 必须发送 STOP 命令 (0x0C) 才能停止采集
- ⚠️ 采集期间其他模块的数据上传可能受影响

### 数字逻辑捕获停止 (功能码 0x0C)
| 字段   | 字节数 | 说明   |
| ------ | ------ | ------ |
| 数据体 | 0      | 无数据 |

**功能说明**：
- 停止正在进行的数字逻辑捕获
- 释放 USB 带宽
- 允许其他模块正常上传数据

**示例**：
```
发送: AA 55 0C 00 00 12
      ^^^^帧头 ^^功能码 ^^^^长度=0 ^^校验和
响应: 无（采集停止，数据流中断）
```

**完整采集流程示例**：
```
1. 启动 1MHz 采样:
   AA 55 0B 00 02 00 3C 9F

2. 接收连续数据流 (无协议头):
   AA 55 FF 00 AA 55 ... (持续接收)

3. 停止采集:
   AA 55 0C 00 00 12

4. 数据流停止
```

### 自定义波形上传 (功能码 0xFC)

该功能允许用户上传任意波形数据到FPGA内部RAM，突破预定义波形限制，实现真正的任意波形输出。**支持双通道独立波形配置**。

#### 数据格式

| 字段     | 字节数 | 说明                                   |
| -------- | ------ | -------------------------------------- |
| 控制字   | 1      | 操作模式、配置标志和通道选择           |
| 波形长度 | 2      | 波形采样点数 (1-4096)，大端模式        |
| 采样率字 | 4      | DDS频率控制字，控制播放速率，大端模式  |
| 波形数据 | N×2    | 每个采样点14位，按2字节打包 (高2位填0) |

#### 控制字定义 (Bit[7:0])

| 位域     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| Bit[1:0] | 操作模式：<br>`00` = 写入新波形（清除旧数据）<br>`01` = 追加波形数据（分包传输）<br>`10` = 启动播放<br>`11` = 停止播放 |
| Bit[2]   | 循环模式：`0` = 单次播放，`1` = 循环播放                     |
| Bit[3]   | 通道选择：`0` = 通道A，`1` = 通道B                           |
| Bit[7:4] | 保留，填0                                                    |

#### 波形数据编码

每个采样点为14位DAC数据，范围 `0x0000 - 0x3FFF`：
- `0x0000`: 最小输出电压
- `0x2000`: 中间电压（零点偏移）
- `0x3FFF`: 最大输出电压

每个采样点打包为2字节（小端模式）：
```
采样点值: 0x2A5C (14位有效)
字节[0] = 0x5C (低字节)
字节[1] = 0x2A (高字节，仅低6位有效)
```

#### 采样率字计算

采样率字控制波形播放速度，使用与DAC配置相同的DDS频率字：

```
sample_rate_word = round((波形播放频率 × 2^20) / DAC时钟频率)
```

**示例**：
- DAC时钟：120MHz
- 波形长度：256点
- 期望输出频率：1kHz
- 波形播放频率 = 1kHz × 256点 = 256kHz
- sample_rate_word = round((256kHz × 2^20) / 120MHz) = 2241
- 最终发送时至少取1以避免静止输出

#### 分包传输策略

单个USB-CDC帧最大65535字节，256点波形只需512字节数据，通常可一次发送：

**单包发送** (控制字[1:0] = `00`):
```
控制字 | 波形长度 | 采样率字 | 256个采样点
  1B   |   2B     |   4B     |  512B
```

**启动播放** (控制字[1:0] = `10`):
```
控制字 | 0x0000 | 0x00000000
  1B   |   2B   |     4B
```
最小7字节命令，仅包含头部，无波形数据

#### 使用示例

**示例1：一次性上传波形（128点）**
```
发送: AA 55 FC 01 03 04 00 80 00 08 C1 00 [256字节波形数据...] XX
      ^^^^帧头 ^^功能码 ^^^^长度(259) ^^控制字(写入+循环) ^^^^波形长度(128) ^^^^^^^^采样率字 ^^^^^^波形数据 ^^校验和

控制字=0x04: Bit[2]=1(循环), Bit[1:0]=00(写入新波形)
```

**示例2：上传256点波形并循环播放**

上传波形（256点）：
```
发送: AA 55 FC 02 03 00 01 00 00 08 C1 00 [512字节波形数据...] XX
      ^^^^帧头 ^^功能码 ^^^^长度(519) ^^控制字(写入) ^^^^波形长度(256) ^^^^^^^^采样率字 ^^^^^^256点 ^^校验和

控制字=0x00: Bit[1:0]=00(写入新波形)
```

启动循环播放：
```
发送: AA 55 FC 00 07 06 00 00 00 00 00 00 XX
      ^^^^帧头 ^^功能码 ^^^^长度(7) ^^控制字(启动+循环) ^^^^填0 ^^^^^^^^填0 ^^校验和

控制字=0x06: Bit[2]=1(循环), Bit[1:0]=10(启动播放)
```

**示例3：停止播放**
```
发送: AA 55 FC 00 07 03 00 00 00 00 00 00 XX
      ^^^^帧头 ^^功能码 ^^^^长度(7) ^^控制字(停止) ^^^^填0 ^^^^^^^^填0 ^^校验和

控制字=0x03: Bit[1:0]=11(停止播放)
```

#### 使用流程

1. **上传波形**: 发送控制字=`0x00`或`0x04`的单包（256点以内无需分包）
2. **启动播放**: 发送控制字=`0x02`（单次）或`0x06`（循环）
3. **修改波形**: 重复步骤1（会覆盖旧波形）
4. **停止播放**: 发送控制字=`0x03`

#### 响应

成功接收返回状态帧（可选实现）：
```
响应: AA 44 FC 00 02 状态码 错误码 XX
      ^^^^上传帧头 ^^自定义波形源 ^^^^长度 ^^^^^^状态 ^^错误 ^^校验和

状态码: 0x00=成功, 0x01=接收中, 0xFF=错误
错误码: 0x00=无错误, 0x01=长度错误, 0x02=地址溢出
```

#### 限制

- 最大波形长度: 256个采样点（512字节）
- 采样点精度: 14位 (0-16383)
- 建议分包大小: ≤512字节/包
- DAC时钟频率: 120MHz (固定)

### DAC配置 (功能码 0xFD)

**支持双通道独立配置**。每个通道可配置不同的波形类型、频率和相位。

| 字段     | 字节数 | 说明                                                |
| -------- | ------ | --------------------------------------------------- |
| 通道号   | 1      | 0: 通道A, 1: 通道B                                  |
| 波形类型 | 1      | 0: 正弦波, 1: 三角波, 2: 锯齿波, 3: 方波, 4: 梯形波 |
| 频率字   | 4      | 32位整数，DDS频率控制字，大端模式                   |
| 相位字   | 4      | 32位整数，DDS相位控制字，大端模式                   |

**频率字计算公式**：
fre_word = (目标频率 × 2^32) / DAC时钟频率

**示例**：
- DAC时钟频率：200MHz
- 生成1MHz信号：fre_word = (1MHz × 2^32) / 200MHz = 21474836

**相位字计算公式**：
pha_word = (目标相位角度 × 2^32) / 360°

**示例**：
- 90度相位：pha_word = (90° × 2^32) / 360° = 1073741824

### PWM配置 (功能码 0xFE)
| 字段   | 字节数 | 说明             |
| ------ | ------ | ---------------- |
| 通道号 | 1      | PWM输出通道编号  |
| 周期   | 2      | 32位整数，单位ns |
| 占空比 | 2      | 32位整数，单位ns |

### 1-Wire 复位 (功能码 0x20)
| 字段   | 字节数 | 说明   |
| ------ | ------ | ------ |
| 数据体 | 0      | 无数据 |

**功能说明**：
- 执行 1-Wire 总线复位序列
- 主机拉低总线 480µs，然后释放
- 等待从机应答脉冲（60-240µs 低电平）
- 用于每次通信前初始化总线或检测从机在线状态
- **这是零长度命令**，无需等待 cmd_done

**时序说明**：
```
主机：  ___┐         ┌─────────
         └─────────┘  (480µs)
从机：  ─────────┐   ┌────────
               └───┘  (60-240µs)
```

**示例**：
```
发送: AA 55 20 00 00 20
      ^^^^帧头 ^^功能码 ^^^^长度=0 ^^校验和

校验和计算: (0x20 + 0x00 + 0x00) & 0xFF = 0x20

响应: 无（零长度命令，立即完成）
```

### 1-Wire 写字节 (功能码 0x21)

| 字段   | 字节数 | 说明                     |
| ------ | ------ | ------------------------ |
| 写数据 | N      | 要发送的数据字节 (1-255) |

**功能说明**：
- 向 1-Wire 总线写入一个或多个字节
- LSB first（最低位先发）
- 用于发送 ROM 命令（0x33/0xCC等）或功能命令（0x44/0xBE等）
- 每个字节需要 8 个写时隙，每时隙约 60-120µs

**时序说明**（单个写时隙）：
```
写 1:  ___┐     ┌────────────
         └─┘    (1-15µs低)
写 0:  ___┐         ┌────────
         └─────────┘ (60µs低)
```

**示例 1**：写 Skip ROM 命令 (0xCC)
```
发送: AA 55 21 00 01 CC EE
      ^^^^帧头 ^^功能码 ^^^^长度=1 ^^数据 ^^校验和

校验和计算: (0x21 + 0x00 + 0x01 + 0xCC) & 0xFF = 0xEE

响应: 无（写操作不返回数据）
```

**示例 2**：写 Convert T 命令 (0x44)
```
发送: AA 55 21 00 01 44 66
      ^^^^帧头 ^^功能码 ^^^^长度=1 ^^数据 ^^校验和

校验和计算: (0x21 + 0x00 + 0x01 + 0x44) & 0xFF = 0x66

响应: 无
```

**示例 3**：写多个字节（不常用）
```
发送: AA 55 21 00 03 CC 44 BE 70
      ^^^^帧头 ^^功能码 ^^^^长度=3 ^^^^^^3个字节 ^^校验和
```

### 1-Wire 读字节 (功能码 0x22)
| 字段     | 字节数 | 说明                              |
| -------- | ------ | --------------------------------- |
| 读取长度 | 2      | 要读取的字节数（16位大端，0-255） |

**功能说明**：
- 从 1-Wire 总线读取指定数量的字节
- LSB first（最低位先读）
- 每个字节需要 8 个读时隙，每时隙约 60µs
- **数据长度字段表示要读取的字节数，不是数据体长度**

**时序说明**（单个读时隙）：
```
主机：  ___┐   ┌─────────────
         └─┘   (1µs低)
从机：  ───?───────────────
           ↑ (15µs采样)
```

**示例**：读取 8 字节 ROM ID
```
发送: AA 55 22 00 08 4A
      ^^^^帧头 ^^功能码 ^^^^长度=8 ^^校验和

校验和计算: (0x22 + 0x00 + 0x08) & 0xFF = 0x2A
注意：文档中原来的校验和 0x2B 是错误的

响应: AA 44 04 00 08 [8字节ROM ID] YY
      ^^^^上传帧头 ^^1-Wire源 ^^^^长度=8 ^^^ROM ID^^^ ^^校验和

ROM ID格式: [Family Code(1B)][Serial Number(6B)][CRC(1B)]
例如: 28 0C 0A 5A 34 12 E7 (Family=0x28=DS18B20)
```

**重要说明**：
- ⚠️ 0x22 命令不常用，因为读操作通常需要先写命令
- ⚠️ 大多数情况应使用 0x23（写读操作）代替
- ⚠️ 读取前必须先执行复位和 ROM 命令

### 1-Wire 写读操作 (功能码 0x23)
| 字段   | 字节数    | 说明                   |
| ------ | --------- | ---------------------- |
| 写长度 | 1         | 要发送的字节数 (0-255) |
| 读长度 | 1         | 要读取的字节数 (0-255) |
| 写数据 | write_len | 要发送的数据           |

**功能说明**：
- **最常用的 1-Wire 操作模式**
- 先写入命令/地址，然后读取响应数据
- 适用于所有需要先发命令再读数据的场景
- 数据体长度 = 2 + write_len

**响应数据格式**：
- 帧头：0xAA44（上传数据标识）
- 数据来源：0x04（1-Wire 模块）
- 数据长度：read_len（16位大端）
- 数据体：读取的 read_len 个字节
- 校验和：所有字节累加和的低8位

**示例 1**：DS18B20 读暂存器（写 1 字节命令，读 9 字节数据）

```
发送: AA 55 23 00 03 01 09 BE EE
      ^^^^帧头 ^^功能码 ^^^^长度=3 ^^写1 ^^读9 ^^Read Scratchpad ^^校验和

校验和计算: (0x23 + 0x00 + 0x03 + 0x01 + 0x09 + 0xBE) & 0xFF = 0xEE

响应: AA 44 04 00 09 [9字节暂存器数据] YY
      ^^^^上传帧头 ^^1-Wire源 ^^^^长度=9 ^^^暂存器内容^^^ ^^校验和

暂存器格式 (9字节):
  [0-1]: 温度 LSB, MSB (16位有符号数)
  [2-3]: TH/TL 报警阈值
  [4]:   配置寄存器 (分辨率)
  [5-7]: 保留 (0xFF, 0x00, 0x10)
  [8]:   CRC8 校验
```

**示例 2**：读取 ROM ID（写 1 字节命令，读 8 字节 ID）
```
发送: AA 55 23 00 03 01 08 33 8F
      ^^^^帧头 ^^功能码 ^^^^长度=3 ^^写1 ^^读8 ^^Read ROM (0x33) ^^校验和

校验和计算: (0x23 + 0x00 + 0x03 + 0x01 + 0x08 + 0x33) & 0xFF = 0x8F

响应: AA 44 04 00 08 [8字节ROM ID] YY
      ^^^^上传帧头 ^^1-Wire源 ^^^^长度=8 ^^^ROM ID^^^ ^^校验和
```

**示例 3**：写多字节读多字节（不常用）
```
发送: AA 55 23 00 05 02 04 AA BB YY
      ^^^^帧头 ^^功能码 ^^^^长度=5 ^^写2 ^^读4 ^^数据 ^^校验和

数据长度 = 2 (写长度+读长度) + 2 (写数据字节数) = 2 + 2 = 4
但这里标注长度为5是错误的，应该是 2+write_len = 2+2 = 4
```

### DS18B20 完整读温度流程（已验证）

以下是经过实际测试验证的完整命令序列：

```
步骤 1: 复位总线
发送: AA 55 20 00 00 20
      ^^^^帧头 ^^功能码 ^^^^长度=0 ^^校验和 (0x20+0x00+0x00=0x20)
响应: 无

步骤 2: Skip ROM（跳过 ROM 识别，单从机模式）
发送: AA 55 21 00 01 CC EE
      ^^^^帧头 ^^功能码 ^^^^长度=1 ^^Skip ROM (0xCC) ^^校验和
响应: 无

步骤 3: Convert T（启动温度转换）
发送: AA 55 21 00 01 44 66
      ^^^^帧头 ^^功能码 ^^^^长度=1 ^^Convert T (0x44) ^^校验和
响应: 无

步骤 4: 等待转换完成
⏱️ 延时 750ms（12位分辨率最大转换时间）
   - 9位分辨率: 93.75ms
   - 10位分辨率: 187.5ms
   - 11位分辨率: 375ms
   - 12位分辨率: 750ms (默认)

步骤 5: 再次复位
发送: AA 55 20 00 00 20
      ^^^^帧头 ^^功能码 ^^^^长度=0 ^^校验和
响应: 无

步骤 6: 再次 Skip ROM
发送: AA 55 21 00 01 CC EE
      ^^^^帧头 ^^功能码 ^^^^长度=1 ^^Skip ROM ^^校验和
响应: 无

步骤 7: 读暂存器（写 Read Scratchpad 命令 0xBE，读 9 字节）
发送: AA 55 23 00 03 01 09 BE EE
      ^^^^帧头 ^^功能码 ^^^^长度=3 ^^写1 ^^读9 ^^Read Scratchpad ^^校验和

校验和: (0x23 + 0x00 + 0x03 + 0x01 + 0x09 + 0xBE) & 0xFF = 0xEE

响应: AA 44 04 00 09 90 01 4B 46 7F FF 00 10 C4 YY
      ^^^^上传帧头 ^^1-Wire源 ^^^^长度=9 ^^^^^^9字节暂存器数据^^^^ ^^校验和

      数据解析:
      [0]=0x90, [1]=0x01 → 温度原始值 = 0x0190 = 400
      温度 °C = 400 / 16.0 = 25.0°C
      [2]=0x4B → TH 报警阈值 (+75°C)
      [3]=0x46 → TL 报警阈值 (+70°C)
      [4]=0x7F → 配置 (12位分辨率: 0x7F)
      [5-7] → 保留字节
      [8]=0xC4 → CRC8 校验

步骤 8: 温度计算公式
温度(°C) = (int16_t)((T_MSB << 8) | T_LSB) / 16.0

示例:
  0x0190 = 400   →  400/16 = +25.0°C
  0x0032 = 50    →  50/16 = +3.125°C
  0xFFF2 = -14   → -14/16 = -0.875°C (补码)
  0xFE6F = -401  → -401/16 = -25.0625°C
```

### 1-Wire 常见错误和解决方法

**错误 1**: 读取到全 0xFF 或全 0x00
```
原因: 总线上无从机响应
解决:
  1. 检查硬件连接（数据线、上拉电阻 4.7kΩ）
  2. 确认 DS18B20 供电正常
  3. 使用 0x20 命令测试复位应答
```

**错误 2**: 温度值不变或异常
```
原因: Convert T 后未等待足够时间
解决: 确保延时至少 750ms（12位分辨率）
```

**错误 3**: 校验和错误
```
原因: CRC8 校验失败
解决:
  1. 重新读取暂存器
  2. 检查总线信号质量（上拉电阻、线长）
  3. 降低通信速率
```

**错误 4**: 多从机环境下读取混乱
```
原因: Skip ROM (0xCC) 只适用于单从机
解决: 使用 Match ROM (0x55) + 8字节 ROM ID
```

### 1-Wire 命令对照表

| 命令代码 | 命令名称        | 功能说明                 |
| -------- | --------------- | ------------------------ |
| 0x33     | Read ROM        | 读取 ROM ID（单从机）    |
| 0x55     | Match ROM       | 匹配指定 ROM ID          |
| 0xCC     | Skip ROM        | 跳过 ROM（单从机快速）   |
| 0xF0     | Search ROM      | 搜索总线上所有从机       |
| 0xEC     | Alarm Search    | 搜索报警的从机           |
| 0x44     | Convert T       | 启动温度转换             |
| 0xBE     | Read Scratchpad | 读暂存器（含温度）       |
| 0x4E     | Write Scratchpad| 写暂存器（TH/TL/Config） |
| 0x48     | Copy Scratchpad | 复制暂存器到 EEPROM      |
| 0xB8     | Recall E2       | 从 EEPROM 恢复暂存器     |

### CAN总线配置 (功能码 0x27)

| 字段           | 字节数 | 说明                                        |
| -------------- | ------ | ------------------------------------------- |
| 本地发送ID     | 2      | 11位短ID，小端模式（低字节在前）            |
| 接收ID短过滤器 | 2      | 11位短ID过滤器，小端模式                    |
| 接收ID短掩码   | 2      | 11位短ID掩码，小端模式（1表示必须匹配该位） |
| 接收ID长过滤器 | 4      | 29位长ID过滤器，小端模式                    |
| 接收ID长掩码   | 4      | 29位长ID掩码，小端模式                      |
| 时序参数PTS    | 2      | 16位时序参数，用于波特率配置，小端模式      |

**数据长度**: 16字节

**功能说明**：
- 配置CAN总线的波特率、发送ID和接收过滤器
- 本地发送ID用于发送CAN帧时的标识符（11位标准ID）
- 接收过滤器用于筛选需要接收的CAN帧（通过ID匹配）
- 掩码中1表示该位必须匹配，0表示该位不关心（don't care）

**波特率配置**：
CAN波特率由三个时序参数决定：c_pts、c_pbs1、c_pbs2
- 波特率计算公式：`Baudrate = 系统时钟频率 / (c_pts + c_pbs1 + c_pbs2)`
- 对于60MHz系统时钟，默认配置：c_pts=34, c_pbs1=5, c_pbs2=10
- 计算结果：60MHz / (34 + 5 + 10) = 60MHz / 49 ≈ 1.224Mbps
- **注意**：当前仅支持配置c_pts参数，c_pbs1和c_pbs2固定为默认值（5和10）

**ID编码格式**：
- 11位ID存储在2字节中，高5位填0
- 编码方式：`{3'b0, byte[1][2:0], byte[0]}`
- 例如：ID=0x123 → byte[0]=0x23, byte[1]=0x01

**示例**：配置为默认波特率(1.224Mbps)，发送ID=0x001，接收ID=0x002（精确匹配）
```
发送: AA 55 27 00 10 01 00 02 00 FF 07 00 00 00 00 FF FF FF 1F 22 00 7E
      ^^^^帧头 ^^功能码 ^^^^长度=16 ^^^^本地ID ^^^^RX过滤器 ^^^^RX掩码 ^^^^^^^^长ID过滤 ^^^^^^^^长ID掩码 ^^^^PTS ^^校验和

数据体详解（16字节）：
  [0:1]   = 0x0001 → 本地发送ID = 0x001
  [2:3]   = 0x0002 → 接收短ID过滤 = 0x002
  [4:5]   = 0x07FF → 接收短ID掩码 = 0x7FF (精确匹配11位)
  [6:9]   = 0x00000000 → 接收长ID过滤器 (4字节，小端)
  [10:13] = 0x1FFFFFFF → 接收长ID掩码 (4字节，小端: FF FF FF 1F)
  [14:15] = 0x0022 → c_pts = 34 (小端: 22 00)
```

### CAN发送数据帧 (功能码 0x28)

| 字段     | 字节数 | 说明                  |
| -------- | ------ | --------------------- |
| CAN数据  | 4      | 要发送的CAN帧数据     |

**数据长度**: 固定4字节

**功能说明**：
- 发送CAN数据帧到总线
- 使用配置的本地ID作为发送者标识符
- **当前实现限制为固定4字节数据长度**（标准CAN支持0-8字节）
- 数据打包顺序：`{byte[3], byte[2], byte[1], byte[0]}`

**示例1**：发送4字节数据 0x11 0x22 0x33 0x44
```
发送: AA 55 28 00 04 11 22 33 44 D6
      ^^^^帧头 ^^功能码 ^^^^长度=4 ^^^^^^^^CAN数据 ^^校验和

响应: 无（发送操作）
```

**示例2**：发送4字节数据 0xAA 0xBB 0xCC 0xDD
```
发送: AA 55 28 00 04 AA BB CC DD 3A
      ^^^^帧头 ^^功能码 ^^^^长度=4 ^^^^^^^^CAN数据 ^^校验和
```

**注意事项**：
- ⚠️ **数据长度必须为4字节**，不足4字节需要填充
- ⚠️ CAN帧的DLC字段固定为4
- ⚠️ 数据发送顺序：byte[3]最先发送，byte[0]最后发送（MSB先发）

### CAN读取接收数据 (功能码 0x29)

| 字段   | 字节数 | 说明   |
| ------ | ------ | ------ |
| 数据体 | 0      | 无数据 |

**功能说明**：
- 读取CAN总线接收到的数据帧
- 只接收通过ID过滤器的帧
- 接收到的数据自动上传到USB CDC接口

**响应数据格式**：
- 帧头：0xAA44（上传数据标识）
- 数据来源：0x05（CAN模块）
- 数据长度：接收到的数据字节数
- 数据体：实际接收的CAN帧数据（逐字节）

**示例**：读取接收到的CAN数据
```
发送: AA 55 29 00 00 29
      ^^^^帧头 ^^功能码 ^^^^长度=0 ^^校验和

响应: AA 44 05 00 04 AA BB CC DD XX
      ^^^^上传帧头 ^^CAN源 ^^^^长度=4 ^^^^^^^^接收数据 ^^校验和
```

**完整使用流程**：
```
1. 配置CAN总线 (0x27):
   AA 55 27 00 10 01 00 02 00 FF 07 00 00 00 00 FF FF FF 1F 22 00 7E
   (配置为1.224Mbps，本地ID=0x001，接收ID=0x002)

2. 发送CAN数据帧 (0x28):
   AA 55 28 00 04 11 22 33 44 D6
   (发送4字节数据)

3. 读取CAN接收数据 (0x29):
   AA 55 29 00 00 29
   (读取接收缓冲区中的数据)

4. 接收响应:
   AA 44 05 00 04 AA BB CC DD XX
   (收到来自其他CAN节点的数据)
```

**注意事项**：
- ⚠️ 发送前必须先配置CAN总线参数（波特率、ID）
- ⚠️ 接收过滤器配置不当可能导致无法接收数据
- ⚠️ CAN总线需要外部CAN收发器（如TJA1050）
- ⚠️ CAN总线需要120Ω终端电阻
- ⚠️ 接收缓冲区大小为16字节，接收数据按字节存储
- ⚠️ 上传的数据不包含CAN帧ID信息，仅包含数据字节

### 心跳测试 (功能码 0xFF)
数据体为空，响应数据体也为空

## 数据来源标识 (上传数据)

| 数据来源        | 标识 | 说明                               |
| --------------- | ---- | ---------------------------------- |
| UART            | 0x01 | 外部 UART 接收数据                 |
| SPI             | 0x03 | SPI 读取数据                       |
| 1-Wire          | 0x04 | 1-Wire 读取数据                    |
| CAN             | 0x05 | CAN总线接收数据                    |
| DSM             | 0x0A | 数字信号测量数据                   |
| Digital Capture | 0x0B | 数字逻辑捕获（直通模式，无协议头） |

**注意**：
- Digital Capture (0x0B) 采用**直通上传模式**，数据流中**无协议头**
- 其他模块采用标准协议格式：`0xAA44 + source + length + data + checksum`

## 校验和

从帧头开始到数据体结束的所有字节的累加和，取低8位。

// 校验和的累加实际上是从功能码（CMD）字节开始的，不包含 0xAA 和 0x55
