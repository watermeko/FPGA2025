module i2c_control(
	Clk,
	Rst_n,
	
	wrreg_req,
	rdreg_req,
	addr,
	addr_mode,
	wrdata,
	rddata,
	device_id,
	RW_Done,
	
	ack,
	
	i2c_sclk,
	i2c_sdat
);

	input Clk;
	input Rst_n;
	
	input wrreg_req;
	input rdreg_req;
	input [15:0]addr;
	input addr_mode;
	input [7:0]wrdata;
	output reg[7:0]rddata;
	input [7:0]device_id;
	output reg RW_Done;
	
	output reg ack;

	output i2c_sclk;
	inout i2c_sdat;
	
	reg [5:0]Cmd;
	reg [7:0]Tx_DATA;
	wire Trans_Done;
	wire ack_o;
	reg Go;
	wire [15:0] reg_addr;
	
	assign reg_addr = addr_mode?addr:{addr[7:0],addr[15:8]};
	
	wire [7:0]Rx_DATA;
	
	localparam 
		WR   = 6'b000001,   //写请求
		STA  = 6'b000010,   //起始位请求
		RD   = 6'b000100,   //读请求
		STO  = 6'b001000,   //停止位请求
		ACK  = 6'b010000,   //应答位请求
		NACK = 6'b100000;   //无应答请求
	
	i2c_bit_shift i2c_bit_shift(
		.Clk(Clk),
		.Rst_n(Rst_n),
		.Cmd(Cmd),
		.Go(Go),
		.Rx_DATA(Rx_DATA),
		.Tx_DATA(Tx_DATA),
		.Trans_Done(Trans_Done),
		.ack_o(ack_o),
		.i2c_sclk(i2c_sclk),
		.i2c_sdat(i2c_sdat)
	);
	
	reg [6:0]state;
	reg [7:0]cnt;
	
	localparam
		IDLE         = 7'b0000001,   //空闲状态
		WR_REG       = 7'b0000010,   //写寄存器状态
		WAIT_WR_DONE = 7'b0000100,   //等待写寄存器完成状态
		WR_REG_DONE  = 7'b0001000,   //写寄存器完成状态
		RD_REG       = 7'b0010000,   //读寄存器状态
		WAIT_RD_DONE = 7'b0100000,   //等待读寄存器完成状态
		RD_REG_DONE  = 7'b1000000;   //读寄存器完成状态
	
	always@(posedge Clk or negedge Rst_n)
	if(!Rst_n)begin
		Cmd <= 6'd0;
		Tx_DATA <= 8'd0;
		Go <= 1'b0;
		rddata <= 0;
		state <= IDLE;
		ack <= 0;
	end
	else begin
		case(state)
			IDLE:
				begin
					cnt <= 0;
					ack <= 0;
					RW_Done <= 1'b0;					
					if(wrreg_req)
						state <= WR_REG;
					else if(rdreg_req)
						state <= RD_REG;
					else
						state <= IDLE;
				end
			
			WR_REG:
				begin
					state <= WAIT_WR_DONE;
					case(cnt)
						0:write_byte(WR | STA, device_id);
						1:write_byte(WR, reg_addr[15:8]);
						2:write_byte(WR, reg_addr[7:0]);
						3:write_byte(WR | STO, wrdata);
						default:;
					endcase
				end
			
			WAIT_WR_DONE:
				begin
					Go <= 1'b0; 
					if(Trans_Done)begin
						ack <= ack | ack_o;
						case(cnt)
							0: begin cnt <= 1; state <= WR_REG;end
							1: 
								begin 
									state <= WR_REG;
									if(addr_mode)
										cnt <= 2; 
									else
										cnt <= 3;
								end
									
							2: begin
									cnt <= 3;
									state <= WR_REG;
								end
							3:state <= WR_REG_DONE;
							default:state <= IDLE;
						endcase
					end
				end
			
			WR_REG_DONE:
				begin
					RW_Done <= 1'b1;
					state <= IDLE;
				end
				
			RD_REG:
				begin
					state <= WAIT_RD_DONE;
					case(cnt)
						0:write_byte(WR | STA, device_id);
						1:write_byte(WR, reg_addr[15:8]);
						2:write_byte(WR, reg_addr[7:0]);
						3:write_byte(WR | STA, device_id | 8'd1);
						4:read_byte(RD | NACK | STO);
						default:;
					endcase
				end
				
			WAIT_RD_DONE:
				begin
					Go <= 1'b0; 
					if(Trans_Done)begin
						if(cnt <= 3)
							ack <= ack | ack_o;
						case(cnt)
							0: begin cnt <= 1; state <= RD_REG;end
							1: 
								begin 
									state <= RD_REG;
									if(addr_mode)
										cnt <= 2; 
									else
										cnt <= 3;
								end
									
							2: begin
									cnt <= 3;
									state <= RD_REG;
								end
							3:begin
									cnt <= 4;
									state <= RD_REG;
								end
							4:state <= RD_REG_DONE;
							default:state <= IDLE;
						endcase
					end
				end
				
			RD_REG_DONE:
				begin
					RW_Done <= 1'b1;
					rddata <= Rx_DATA;
					state <= IDLE;				
				end
			default:state <= IDLE;
		endcase
	end
	
	task read_byte;
		input [5:0]Ctrl_Cmd;
		begin
			Cmd <= Ctrl_Cmd;
			Go <= 1'b1; 
		end
	endtask
	
	task write_byte;
		input [5:0]Ctrl_Cmd;
		input [7:0]Wr_Byte_Data;
		begin
			Cmd <= Ctrl_Cmd;
			Tx_DATA <= Wr_Byte_Data;
			Go <= 1'b1; 
		end
	endtask

endmodule

module i2c_bit_shift(
	Clk,
	Rst_n,
	
	Cmd,
	Go,
	Rx_DATA,
	Tx_DATA,
	Trans_Done,
	ack_o,
	i2c_sclk,
	i2c_sdat
);
	input Clk;
	input Rst_n;
	
	input [5:0]Cmd;
	input Go;
	output reg[7:0]Rx_DATA;
	input [7:0]Tx_DATA;
	output reg Trans_Done;
	output reg ack_o;
	output reg i2c_sclk;
	inout i2c_sdat;
	
	reg i2c_sdat_o;

	//系统时钟采用50MHz
	parameter SYS_CLOCK = 50_000_000;
	//SCL总线时钟采用400kHz  -->> 修改为 350kHz
	parameter SCL_CLOCK = 350_000; // <<<--- 修改此处 原来是400kHz
	//产生时钟SCL计数器最大值
	localparam SCL_CNT_M = SYS_CLOCK/SCL_CLOCK/4 - 1;
	
	reg i2c_sdat_oe;
	
	localparam 
		WR   = 6'b000001,   //写请求
		STA  = 6'b000010,   //起始位请求
		RD   = 6'b000100,   //读请求
		STO  = 6'b001000,   //停止位请求
		ACK  = 6'b010000,   //应答位请求
		NACK = 6'b100000;   //无应答请求
		
	reg [19:0]div_cnt;
	reg en_div_cnt;
	always@(posedge Clk or negedge Rst_n)
	if(!Rst_n)
		div_cnt <= 20'd0;
	else if(en_div_cnt)begin
		if(div_cnt < SCL_CNT_M)
			div_cnt <= div_cnt + 1'b1;
		else
			div_cnt <= 0;
	end
	else
		div_cnt <= 0;

	wire sclk_plus = div_cnt == SCL_CNT_M;
	
	//assign i2c_sdat = i2c_sdat_oe?i2c_sdat_o:1'bz;
	assign i2c_sdat = !i2c_sdat_o && i2c_sdat_oe ? 1'b0:1'bz;
		
	reg [7:0]state;
	
	localparam
		IDLE      = 8'b00000001,   //空闲状态
		GEN_STA   = 8'b00000010,   //产生起始信号
		WR_DATA   = 8'b00000100,   //写数据状态
		RD_DATA   = 8'b00001000,   //读数据状态
		CHECK_ACK = 8'b00010000,   //检测应答状态
		GEN_ACK   = 8'b00100000,   //产生应答状态
		GEN_STO   = 8'b01000000;   //产生停止信号
		
	reg [4:0]cnt;
		
	always@(posedge Clk or negedge Rst_n)
	if(!Rst_n)begin
		Rx_DATA <= 0;
		i2c_sdat_oe <= 1'd0;
		en_div_cnt <= 1'b0;
		i2c_sdat_o <= 1'd1;
		Trans_Done <= 1'b0;
		ack_o <= 0;
		state <= IDLE;
		cnt <= 0;
		// i2c_sclk <= 1'b1;       // <--- 新增：SCL 空闲时为高
    	// i2c_sdat_oe <= 1'd0;    // <--- 明确：复位时释放SDA
	end
	else begin
		case(state)
			IDLE:
				begin
					Trans_Done <= 1'b0;
					i2c_sdat_oe <= 1'd1;
//					i2c_sdat_oe <= 1'd0;    // <--- 修正2：IDLE状态下应该释放总线
					if(Go)begin
						en_div_cnt <= 1'b1;
						if(Cmd & STA)
							state <= GEN_STA;
						else if(Cmd & WR)
							state <= WR_DATA;
						else if(Cmd & RD)
							state <= RD_DATA;
						else
							state <= IDLE;
					end
					else begin
						en_div_cnt <= 1'b0;
						state <= IDLE;
					end
				end
				
			GEN_STA:
				begin
					if(sclk_plus)begin
						if(cnt == 3)
							cnt <= 0;
						else
							cnt <= cnt + 1'b1;
						case(cnt)
							0:begin i2c_sdat_o <= 1; i2c_sdat_oe <= 1'd1;end
							1:begin i2c_sclk <= 1;end
							2:begin i2c_sdat_o <= 0; i2c_sclk <= 1;end
							3:begin i2c_sclk <= 0;end
							default:begin i2c_sdat_o <= 1; i2c_sclk <= 1;end
						endcase
						if(cnt == 3)begin
							if(Cmd & WR)
								state <= WR_DATA;
							else if(Cmd & RD)
								state <= RD_DATA;
						end
					end
				end
				
			WR_DATA:
				begin
					if(sclk_plus)begin
						if(cnt == 31)
							cnt <= 0;
						else
							cnt <= cnt + 1'b1;
						case(cnt)
							0,4,8,12,16,20,24,28:begin i2c_sdat_o <= Tx_DATA[7-cnt[4:2]]; i2c_sdat_oe <= 1'd1;end	//set data;
							1,5,9,13,17,21,25,29:begin i2c_sclk <= 1;end	//sclk posedge
							2,6,10,14,18,22,26,30:begin i2c_sclk <= 1;end	//sclk keep high
							3,7,11,15,19,23,27,31:begin i2c_sclk <= 0;end	//sclk negedge
/*							
							0 :begin i2c_sdat_o <= Tx_DATA[7];end
							1 :begin i2c_sclk <= 1;end	//sclk posedge
							2 :begin i2c_sclk <= 1;end	//sclk keep high
							3 :begin i2c_sclk <= 0;end	//sclk negedge
							
							4 :begin i2c_sdat_o <= Tx_DATA[6];end
							5 :begin i2c_sclk <= 1;end	//sclk posedge
							6 :begin i2c_sclk <= 1;end	//sclk keep high
							7 :begin i2c_sclk <= 0;end	//sclk negedge
							
							8 :begin i2c_sdat_o <= Tx_DATA[5];end
							9 :begin i2c_sclk <= 1;end	//sclk posedge
							10:begin i2c_sclk <= 1;end	//sclk keep high
							11:begin i2c_sclk <= 0;end	//sclk negedge
							
							12:begin i2c_sdat_o <= Tx_DATA[4];end
							13:begin i2c_sclk <= 1;end	//sclk posedge
							14:begin i2c_sclk <= 1;end	//sclk keep high
							15:begin i2c_sclk <= 0;end	//sclk negedge
							
							16:begin i2c_sdat_o <= Tx_DATA[3];end
							17:begin i2c_sclk <= 1;end	//sclk posedge
							18:begin i2c_sclk <= 1;end	//sclk keep high
							19:begin i2c_sclk <= 0;end	//sclk negedge
							
							20:begin i2c_sdat_o <= Tx_DATA[2];end
							21:begin i2c_sclk <= 1;end	//sclk posedge
							22:begin i2c_sclk <= 1;end	//sclk keep high
							23:begin i2c_sclk <= 0;end	//sclk negedge	
							
							24:begin i2c_sdat_o <= Tx_DATA[1];end
							25:begin i2c_sclk <= 1;end	//sclk posedge
							26:begin i2c_sclk <= 1;end	//sclk keep high
							27:begin i2c_sclk <= 0;end	//sclk negedge	
							
							28:begin i2c_sdat_o <= Tx_DATA[0];end
							29:begin i2c_sclk <= 1;end	//sclk posedge
							30:begin i2c_sclk <= 1;end	//sclk keep high
							31:begin i2c_sclk <= 0;end	//sclk negedge
*/							
							default:begin i2c_sdat_o <= 1; i2c_sclk <= 1;end
						endcase
						if(cnt == 31)begin
							state <= CHECK_ACK;
						end
					end
				end
				
			RD_DATA:
				begin
					if(sclk_plus)begin
						if(cnt == 31)
							cnt <= 0;
						else
							cnt <= cnt + 1'b1;
						case(cnt)
							0,4,8,12,16,20,24,28:begin i2c_sdat_oe <= 1'd0; i2c_sclk <= 0;end	//set data;
							1,5,9,13,17,21,25,29:begin i2c_sclk <= 1;end	//sclk posedge
							2,6,10,14,18,22,26,30:begin i2c_sclk <= 1; Rx_DATA <= {Rx_DATA[6:0],i2c_sdat};end	//sclk keep high
							3,7,11,15,19,23,27,31:begin i2c_sclk <= 0;end	//sclk negedge						
							default:begin i2c_sdat_o <= 1; i2c_sclk <= 1;end
						endcase
						if(cnt == 31)begin
							state <= GEN_ACK;
						end
					end
				end
			
			CHECK_ACK:
				begin
					if(sclk_plus)begin
						if(cnt == 3)
							cnt <= 0;
						else
							cnt <= cnt + 1'b1;
						case(cnt)
							0:begin i2c_sdat_oe <= 1'd0; i2c_sclk <= 0;end
							1:begin i2c_sclk <= 1;end
							2:begin ack_o <= i2c_sdat; i2c_sclk <= 1;end
							3:begin i2c_sclk <= 0;end
							default:begin i2c_sdat_o <= 1; i2c_sclk <= 1;end
						endcase
						if(cnt == 3)begin
							if(Cmd & STO)
								state <= GEN_STO;
							else begin
								state <= IDLE;
								Trans_Done <= 1'b1;
							end								
						end
					end
				end
			
			GEN_ACK:
				begin
					if(sclk_plus)begin
						if(cnt == 3)
							cnt <= 0;
						else
							cnt <= cnt + 1'b1;
						case(cnt)
							0:begin 
									i2c_sdat_oe <= 1'd1;
									i2c_sclk <= 0;
									if(Cmd & ACK)
										i2c_sdat_o <= 1'b0;
									else if(Cmd & NACK)
										i2c_sdat_o <= 1'b1;
								end
							1:begin i2c_sclk <= 1;end
							2:begin i2c_sclk <= 1;end
							3:begin i2c_sclk <= 0;end
							default:begin i2c_sdat_o <= 1; i2c_sclk <= 1;end
						endcase
						if(cnt == 3)begin
							if(Cmd & STO)
								state <= GEN_STO;
							else begin
								state <= IDLE;
								Trans_Done <= 1'b1;
							end
						end
					end
				end
			
			GEN_STO:
				begin
					if(sclk_plus)begin
						if(cnt == 3)
							cnt <= 0;
						else
							cnt <= cnt + 1'b1;
						case(cnt)
							0:begin i2c_sdat_o <= 0; i2c_sdat_oe <= 1'd1;end
							1:begin i2c_sclk <= 1;end
							2:begin i2c_sdat_o <= 1; i2c_sclk <= 1;end
							3:begin i2c_sclk <= 1;end
							default:begin i2c_sdat_o <= 1; i2c_sclk <= 1;end
						endcase
						if(cnt == 3)begin
							Trans_Done <= 1'b1;
							state <= IDLE;
						end
					end
				end
			default:state <= IDLE;
		endcase
	end
	
endmodule


/******************************************************************
*   Copyright (C) 2025 Google Inc.
*   
*   Module: i2c_handler
*   Description: 
*       Handles I2C commands from the command_processor.
*       - Parses configuration, write, and read commands.
*       - Drives the i2c_control module to perform single-byte I2C transactions.
*       - Sequences multiple single-byte transactions to handle multi-byte read/write requests.
*       - Uploads read data back to the host via the command_processor.
*
******************************************************************/
module i2c_handler #(
        parameter WRITE_BUFFER_SIZE = 128  // 定义一个用于缓存I2C写数据的缓冲区大小
    )(
        // System Signals
        input wire          clk,
        input wire          rst_n,

        // Command Interface from command_processor
        input wire [7:0]    cmd_type,
        input wire [15:0]   cmd_length,
        input wire [7:0]    cmd_data,
        input wire [15:0]   cmd_data_index,
        input wire          cmd_start,
        input wire          cmd_data_valid,
        input wire          cmd_done,
        output reg          cmd_ready,

        // I2C Physical Interface
        output wire         i2c_scl,
        inout  wire         i2c_sda,

        // Data Upload Interface to command_processor
        output reg          upload_req,
        output reg [7:0]    upload_data,
        output reg [7:0]    upload_source,
        output reg          upload_valid,
        input  wire         upload_ready
    );

    //================================================================
    // I2C Command Codes
    //================================================================
    localparam CMD_I2C_CONFIG = 8'h04;
    localparam CMD_I2C_WRITE  = 8'h05;
    localparam CMD_I2C_READ   = 8'h06;
    
    //================================================================
    // State Machine Definition
    //================================================================
    localparam [3:0]
        S_IDLE              = 4'd0,
        S_PARSE_CONFIG      = 4'd1,
        S_PARSE_WRITE       = 4'd2,
        S_PARSE_READ        = 4'd3,
        S_EXEC_WRITE_START  = 4'd4,
        S_EXEC_WRITE_WAIT   = 4'd5,
        S_EXEC_READ_START   = 4'd6,
        S_EXEC_READ_WAIT    = 4'd7,
        S_UPLOAD_START      = 4'd8,
        S_UPLOAD_WAIT       = 4'd9;

    reg [3:0] state;

    //================================================================
    // Internal Registers and Wires
    //================================================================
    // Configuration Registers
    reg [7:0] device_addr_reg;

    // Transaction Registers
    reg [15:0]  reg_addr_reg;
    reg [15:0]  data_len_reg;
    reg [15:0]  data_ptr_reg;
    reg [7:0]   write_buffer [0:WRITE_BUFFER_SIZE-1];
    
    // I2C Control signals
    wire        i2c_rw_done;
    wire [7:0]  i2c_rddata;
    wire        i2c_ack;

    reg         wrreg_req_pulse;
    reg         rdreg_req_pulse;
    reg [7:0]   wrdata_reg;
    
    // Latched read data for upload
    reg [7:0]   latched_rddata;

    //================================================================
    // Instantiate I2C Controller
    //================================================================
    i2c_control u_i2c_control (
        .Clk        (clk),
        .Rst_n      (rst_n),
        .wrreg_req  (wrreg_req_pulse),
        .rdreg_req  (rdreg_req_pulse),
        .addr       (reg_addr_reg + data_ptr_reg), // 地址自动增加
        .addr_mode  (1'b0), // 协议定义为1字节寄存器地址, 故固定为8-bit模式
        .wrdata     (wrdata_reg),
        .rddata     (i2c_rddata),
        .device_id  ({device_addr_reg, 1'b0}), // 7位地址 + W/R位(0)
        .RW_Done    (i2c_rw_done),
        .ack        (i2c_ack),
        .i2c_sclk   (i2c_scl),
        .i2c_sdat   (i2c_sda)
    );
    
    //================================================================
    // Main State Machine
    //================================================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= S_IDLE;
            cmd_ready <= 1'b1;
            device_addr_reg <= 8'h00;
            reg_addr_reg <= 16'h0000;
            data_len_reg <= 16'h0000;
            data_ptr_reg <= 16'h0000;
            wrreg_req_pulse <= 1'b0;
            rdreg_req_pulse <= 1'b0;
            upload_req <= 1'b0;
            upload_valid <= 1'b0;
            upload_data <= 8'h00;
            upload_source <= 8'h00;
        end else begin
            // 默认将脉冲信号拉低
            wrreg_req_pulse <= 1'b0;
            rdreg_req_pulse <= 1'b0;
            upload_valid <= 1'b0;

            case (state)
                S_IDLE: begin
                    cmd_ready <= 1'b1;
                    upload_req <= 1'b0;
                    if (cmd_start) begin
                        case (cmd_type)
                            CMD_I2C_CONFIG: begin
                                state <= S_PARSE_CONFIG;
                            end
                            CMD_I2C_WRITE: begin
                                if (cmd_length > 1 && cmd_length - 1 <= WRITE_BUFFER_SIZE) begin
                                    cmd_ready <= 1'b0; // 准备接收数据，暂时不接受新指令
                                    state <= S_PARSE_WRITE;
                                end
                            end
                            CMD_I2C_READ: begin
                                if (cmd_length == 3) begin // 1B Addr + 2B Len
                                    cmd_ready <= 1'b0;
                                    state <= S_PARSE_READ;
                                end
                            end
                            default: begin
                                // Not an I2C command
                            end
                        endcase
                    end
                end

                // --- Configuration Parsing ---
                S_PARSE_CONFIG: begin
                    cmd_ready <= 1'b1; // 持续接收数据
                    if (cmd_data_valid && cmd_data_index == 4) begin // Index 0-3=Freq, 4=Addr
                        device_addr_reg <= cmd_data;
                    end
                    if (cmd_done) begin
                        state <= S_IDLE;
                    end
                end

                // --- Write Command Parsing ---
                S_PARSE_WRITE: begin
                    cmd_ready <= 1'b1;
                    if (cmd_data_valid) begin
                        if (cmd_data_index == 0) begin
                            reg_addr_reg <= {8'h00, cmd_data};
                        end else begin
                            // cmd_data_index 从1开始是数据
                            write_buffer[cmd_data_index - 1] <= cmd_data;
                        end
                    end
                    if (cmd_done) begin
                        data_len_reg <= cmd_length - 1; // 实际数据长度
                        data_ptr_reg <= 0;
                        state <= S_EXEC_WRITE_START;
                    end
                end

                // --- Read Command Parsing ---
                S_PARSE_READ: begin
                    cmd_ready <= 1'b1;
                    if (cmd_data_valid) begin
                        case(cmd_data_index)
                            0: reg_addr_reg <= {8'h00, cmd_data};
                            1: data_len_reg[15:8] <= cmd_data;
                            2: data_len_reg[7:0] <= cmd_data;
                        endcase
                    end
                    if (cmd_done) begin
                        data_ptr_reg <= 0;
                        state <= S_EXEC_READ_START;
                    end
                end
                
                // --- Write Execution ---
                S_EXEC_WRITE_START: begin
                    if (data_ptr_reg < data_len_reg) begin
                        wrdata_reg <= write_buffer[data_ptr_reg];
                        wrreg_req_pulse <= 1'b1;
                        state <= S_EXEC_WRITE_WAIT;
                    end else begin
                        // All bytes written
                        state <= S_IDLE;
                    end
                end
                
                S_EXEC_WRITE_WAIT: begin
                    if (i2c_rw_done) begin
                        data_ptr_reg <= data_ptr_reg + 1;
                        state <= S_EXEC_WRITE_START;
                    end
                end

                // --- Read Execution ---
                S_EXEC_READ_START: begin
                    if (data_ptr_reg < data_len_reg) begin
                        rdreg_req_pulse <= 1'b1;
                        state <= S_EXEC_READ_WAIT;
                    end else begin
                        // All bytes read and uploaded
                        state <= S_IDLE;
                    end
                end

                S_EXEC_READ_WAIT: begin
                    if (i2c_rw_done) begin
                        latched_rddata <= i2c_rddata;
                        state <= S_UPLOAD_START;
                    end
                end

                // --- Data Upload Logic ---
                S_UPLOAD_START: begin
                    upload_req <= 1'b1;
                    upload_data <= latched_rddata;
                    upload_source <= CMD_I2C_READ; // 使用功能码作为源ID
                    upload_valid <= 1'b1;
                    state <= S_UPLOAD_WAIT;
                end
                
                S_UPLOAD_WAIT: begin
                    if (upload_ready) begin
                        upload_req <= 1'b0; // 对方已接收，撤销请求
                        data_ptr_reg <= data_ptr_reg + 1;
                        state <= S_EXEC_READ_START; // 返回去读下一个字节
                    end
                end

                default: begin
                    state <= S_IDLE;
                end
            endcase
        end
    end

endmodule

module cdc(
        input clk,
        input rst_n,
        
        input [7:0] usb_data_in,
        input       usb_data_valid_in,

        output led_out,
        output [7:0] pwm_pins,

        input ext_uart_rx,
        output ext_uart_tx,

        input dac_clk,
        output [13:0] dac_data,

        inout wire SCL,
        inout wire SDA,
        
        // 数据上传接口
        output [7:0] usb_upload_data,
        output       usb_upload_valid
    );

    wire parser_done,parser_error;
    wire [7:0] cmd_out;
    wire [15:0] len_out;
    parameter PAYLOAD_ADDR_WIDTH=$clog2(256);
    wire [7:0] payload_read_data;
    wire [PAYLOAD_ADDR_WIDTH-1:0] payload_read_addr;
    // 在cdc模块中添加边沿检测
    reg usb_data_valid_in_d1;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            usb_data_valid_in_d1 <= 1'b0;
        end else begin
            usb_data_valid_in_d1 <= usb_data_valid_in;
        end
    end
    
    wire usb_data_valid_pulse = usb_data_valid_in & ~usb_data_valid_in_d1;
    
    // 修改protocol_parser的连接
    protocol_parser #(
        .MAX_PAYLOAD_LEN(256)
    ) u_parser (
        .clk(clk),
        .rst_n(rst_n),
        .uart_rx_data(usb_data_in),
        .uart_rx_valid(usb_data_valid_in),  // 使用脉冲信号

        // Payload read port - not used in this test, tie address to 0
        .payload_read_addr(payload_read_addr),
        .payload_read_data(payload_read_data),

        // Parser outputs
        .parse_done(parser_done),
        .parse_error(parser_error),
        .cmd_out(cmd_out),
        .len_out(len_out)
    );

    // 通用指令接口
    wire [7:0]  cmd_type;
    wire [15:0] cmd_length;
    wire [7:0]  cmd_data;
    wire [15:0] cmd_data_index;
    wire        cmd_start;
    wire        cmd_data_valid;
    wire        cmd_done;
    
    wire i2c_cmd_ready;

    // I2C 上传接口信号
    wire i2c_upload_req;
    wire [7:0] i2c_upload_data;
    wire [7:0] i2c_upload_source;
    wire i2c_upload_valid;

    wire pwm_ready,ext_uart_ready,dac_ready;
    wire cmd_ready = pwm_ready & ext_uart_ready & dac_ready & i2c_cmd_ready;
    
    // 数据上传接口信号
    wire        uart_upload_req;
    wire [7:0]  uart_upload_data;
    wire [7:0]  uart_upload_source;
    wire        uart_upload_valid;
    wire        uart_upload_ready;

    wire upload_req_combined = uart_upload_req | i2c_upload_req; 
    wire [7:0] upload_data_combined = i2c_upload_req ? i2c_upload_data : uart_upload_data;
    wire [7:0] upload_source_combined = i2c_upload_req ? i2c_upload_source : uart_upload_source;
    wire upload_valid_combined = i2c_upload_req ? i2c_upload_valid : uart_upload_valid;


    
    // 数据分发者
    command_processor #(
        .PAYLOAD_ADDR_WIDTH(PAYLOAD_ADDR_WIDTH)
    ) u_command_processor (
        .clk(clk),
        .rst_n(rst_n),
        .parse_done(parser_done),
        .cmd_out(cmd_out),
        .len_out(len_out),
        .payload_read_data(payload_read_data),
        .led_out(led_out),
        .payload_read_addr(payload_read_addr),
        
        .cmd_type_out(cmd_type),
        .cmd_length_out(cmd_length),
        .cmd_data_out(cmd_data),
        .cmd_data_index_out(cmd_data_index),
        .cmd_start_out(cmd_start),
        .cmd_data_valid_out(cmd_data_valid),
        .cmd_done_out(cmd_done),
        .cmd_ready_in(cmd_ready),
        
        // 数据上传接口
        .upload_req_in(upload_req_combined),
        .upload_data_in(upload_data_combined),
        .upload_source_in(upload_source_combined),
        .upload_valid_in(upload_valid_combined),
        
        .usb_upload_data_out(usb_upload_data),
        .usb_upload_valid_out(usb_upload_valid)
    );
    
    // PWM处理器
    pwm_handler u_pwm_handler (
        .clk(clk),
        .rst_n(rst_n),
        .cmd_type(cmd_type),
        .cmd_length(cmd_length),
        .cmd_data(cmd_data),
        .cmd_data_index(cmd_data_index),
        .cmd_start(cmd_start),
        .cmd_data_valid(cmd_data_valid),
        .cmd_done(cmd_done),
        .cmd_ready(pwm_ready),
        
        .pwm_pins(pwm_pins)
    );

    uart_handler u_uart_handler(
        .clk(clk),
        .rst_n(rst_n),
        .cmd_type(cmd_type),
        .cmd_length(cmd_length),
        .cmd_data(cmd_data),
        .cmd_data_index(cmd_data_index),
        .cmd_start(cmd_start),
        .cmd_data_valid(cmd_data_valid),
        .cmd_done(cmd_done),

        .cmd_ready(ext_uart_ready),
        .ext_uart_tx(ext_uart_tx),
        .ext_uart_rx(ext_uart_rx),
        
        // 数据上传接口
        .upload_req(uart_upload_req),
        .upload_data(uart_upload_data),
        .upload_source(uart_upload_source),
        .upload_valid(uart_upload_valid),
        .upload_ready(uart_upload_ready)
    );

    // 例化 i2c_handler
    i2c_handler u_i2c_handler (
        .clk            (clk),
        .rst_n          (rst_n),
        .cmd_type       (cmd_type),
        .cmd_length     (cmd_length),
        .cmd_data       (cmd_data),
        .cmd_data_index (cmd_data_index),
        .cmd_start      (cmd_start),
        .cmd_data_valid (cmd_data_valid),
        .cmd_done       (cmd_done),
        .cmd_ready      (i2c_cmd_ready),

        .i2c_scl        (SCL), // 直接连接到顶层 inout 端口
        .i2c_sda        (SDA), // 直接连接到顶层 inout 端口

        .upload_req     (i2c_upload_req),
        .upload_data    (i2c_upload_data),
        .upload_source  (i2c_upload_source),
        .upload_valid   (i2c_upload_valid),
        .upload_ready   (upload_ready) // 从 command_processor 获取
    );

    dac_handler u_dac_handler(
        .clk            	(clk             ),
        .rst_n          	(rst_n           ),
        .cmd_type       	(cmd_type        ),
        .cmd_length     	(cmd_length      ),
        .cmd_data       	(cmd_data        ),
        .cmd_data_index 	(cmd_data_index  ),
        .cmd_start      	(cmd_start       ),
        .cmd_data_valid 	(cmd_data_valid  ),
        .cmd_done       	(cmd_done        ),
        .cmd_ready      	(dac_ready       ),

        .dac_clk            (dac_clk),
        .dac_data       	(dac_data        )
    );


endmodule

# USB-CDC通信协议

| 字段     | 字节数 |
| -------- | ------ |
| 帧头     | 2      |
| 功能码   | 1      |
| 数据长度 | 2      |
| 数据体   | 0-65535 |
|校验和|1|
|状态字| 1|

## 帧头

固定为0xAA55。

## 功能码

| 功能码 | 功能描述 | 完成情况|
| ------ | -------- | |
| 0x01   | **配置SPI** |  |
| 0x02   | **发送SPI数据** ||
| 0x03   | **接收SPI数据** ||
| 0x04   | **配置I2C** | |
| 0x05   | **发送I2C数据** ||
| 0x06   | **接收I2C数据** ||
| 0x07   | **配置UART** |✅|
| 0x08   | **发送UART数据** |✅|
| 0x09   | **接收UART数据** | ✅ |
| 0x0A   | **数字信号测量** |✅|
| 0xFD   | **配置DAC输出**|✅|
| 0xFE   | **配置PWM输出** |✅|
|0xFF|**心跳测试**|✅|

## 数据长度

- **值**: 16位无符号整数，例如 `0x000A` 表示数据体有10个字节。
- **字节序**: 大端模式（Big-Endian）**，即高字节在前。`0x000A` 发送时就是 `0x00` 先发，`0x0A` 后发。

## 数据体

### SPI配置 (功能码 0x01)
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 模式 | 1 | SPI模式 (0-3) |
| 时钟频率 | 4 | 32位整数，单位Hz |
| 位顺序 | 1 | 0: MSB优先, 1: LSB优先 |
| 片选极性 | 1 | 0: 低电平有效, 1: 高电平有效 |

### SPI发送 (功能码 0x02)
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 片选信号 | 1 | 片选线编号 |
| 发送数据 | N | 要发送的数据字节 |

### SPI接收 (功能码 0x03)
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 片选信号 | 1 | 片选线编号 |
| 读取长度 | 2 | 要读取的数据字节数 |

响应数据体为实际读取到的数据字节

### I2C配置 (功能码 0x04)
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 时钟频率 | 4 | 32位整数，单位Hz |
| 从机地址 | 1 | 7位从机地址 |

### I2C发送 (功能码 0x05)
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 寄存器地址 | 1 | 目标寄存器地址 |
| 发送数据 | N | 要写入的数据字节 |

### I2C接收 (功能码 0x06)
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 寄存器地址 | 1 | 目标寄存器地址 |
| 读取长度 | 2 | 要读取的数据字节数 |

响应数据体为实际读取到的数据字节

### UART配置 (功能码 0x07) 
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 波特率 | 4 | 32位整数，如9600, 115200等 |
| 数据位 | 1 | 5, 6, 7, 8 |
| 停止位 | 1 | 1, 1.5, 2 |
| 校验位 | 1 | 0: 无校验, 1: 奇校验, 2: 偶校验 |

### UART发送 (功能码 0x08)
数据体为要发送的原始数据字节

### UART接收 (功能码 0x09)
数据体为空，响应为接收到的数据字节

### 数字信号测量 (功能码 0x0A)
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 通道掩码 | 1 | 8位掩码，每位对应一个测量通道，1表示启用该通道测量 |

**响应数据格式** (每个启用的通道返回9字节数据)：
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 通道号 | 1 | 当前数据对应的通道号 (0-7) |
| 高电平时间 | 2 | 16位无符号整数，单位：时钟周期 |  
| 低电平时间 | 2 | 16位无符号整数，单位：时钟周期 |
| 周期时间 | 2 | 16位无符号整数，单位：时钟周期 |
| 占空比 | 2 | 16位无符号整数，单位：百分比×100 |

**示例**：
- 启用通道0和2：通道掩码 = 0x05 (二进制: 00000101)
- 返回数据：通道0的9字节数据 + 通道2的9字节数据，共18字节

### DAC配置 (功能码 0xFD)
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 波形类型 | 1 | 0: 正弦波, 1: 三角波, 2: 锯齿波, 3: 方波 |
| 频率字 | 4 | 32位整数，DDS频率控制字，大端模式 |
| 相位字 | 4 | 32位整数，DDS相位控制字，大端模式 |

**频率字计算公式**：
fre_word = (目标频率 × 2^32) / DAC时钟频率

**示例**：
- DAC时钟频率：200MHz
- 生成1MHz信号：fre_word = (1MHz × 2^32) / 200MHz = 21474836

**相位字计算公式**：
pha_word = (目标相位角度 × 2^32) / 360°

**示例**：
- 90度相位：pha_word = (90° × 2^32) / 360° = 1073741824

### PWM配置 (功能码 0xFE)
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 通道号 | 1 | PWM输出通道编号 |
| 周期 | 2 | 32位整数，单位ns |
| 占空比 | 2 | 32位整数，单位ns |

### 心跳测试 (功能码 0xFF)
数据体为空，响应数据体也为空

## 校验和

从帧头开始到数据体结束的所有字节的累加和，取低8位。


以下是仿真文件
`timescale 1ns/1ps

module tb_cdc_i2c_direct_verify;

    //================================================================
    // Testbench Signals
    //================================================================
    
    reg clk;
    reg rst_n;

    reg  [7:0]  usb_data_in;
    reg         usb_data_valid_in;

    wire        SCL;
    wire        SDA;
    
    // Unused CDC ports - still need to be declared for instantiation
    wire [7:0]  usb_upload_data;
    wire        usb_upload_valid;
    wire        led_out;
    wire [7:0]  pwm_pins;
    wire        ext_uart_tx;
    reg         ext_uart_rx = 1'b1;
    wire [13:0] dac_data;
    reg         dac_clk = 0;

    localparam EEPROM_DEVICE_ADDR_8BIT = 8'hA0;
    localparam EEPROM_DEVICE_ADDR_7BIT = EEPROM_DEVICE_ADDR_8BIT >> 1;
    
    // Test Data Definition
    localparam WRITE_ADDR = 8'h3C;
    localparam NUM_BYTES_TO_TEST = 4;
    reg [7:0] expected_data [0:NUM_BYTES_TO_TEST-1];
    reg [7:0] tb_payload [0:127];

    integer i;

    //================================================================
    // DUT and Slave Instantiation
    //================================================================

    cdc u_dut (
        .clk(clk), .rst_n(rst_n), .usb_data_in(usb_data_in), .usb_data_valid_in(usb_data_valid_in),
        .led_out(led_out), .pwm_pins(pwm_pins), .ext_uart_rx(ext_uart_rx), .ext_uart_tx(ext_uart_tx),
        .dac_clk(dac_clk), .dac_data(dac_data), .SCL(SCL), .SDA(SDA),
        .usb_upload_data(usb_upload_data), .usb_upload_valid(usb_upload_valid)
    );
    
    M24LC04B u_eeprom (
        .A0(1'b0), .A1(1'b0), .A2(1'b0), .WP(1'b0), 
        .SDA(SDA), .SCL(SCL), .RESET(1'b0)
    );
    // *** ADD THESE LINES TO SIMULATE PULL-UP RESISTORS ***
    pullup(SCL);
    pullup(SDA);
    //================================================================
    // Clock and Reset Generation
    //================================================================
    
    initial begin clk = 0; forever #10 clk = ~clk; end
    initial begin rst_n = 1'b0; #100; rst_n = 1'b1; end
    
    //================================================================
    // Test Sequence
    //================================================================
    
    initial begin
        // Initialize test data
        expected_data[0] = 8'hDE;
        expected_data[1] = 8'hAD;
        expected_data[2] = 8'hBE;
        expected_data[3] = 8'hEF;

        $display("-----------------------------------------------------");
        $display("--- Starting CDC I2C Direct Verification Test ---");
        $display("-----------------------------------------------------");

        wait (rst_n === 1'b1);
        #100;

        // --- TEST 1: Configure I2C ---
        $display("[%t] TEST 1: Sending I2C Config command (0x04)...", $time);
        tb_payload[0] = 8'h00; tb_payload[1] = 8'h01; tb_payload[2] = 8'h02; tb_payload[3] = 8'h03;
        tb_payload[4] = EEPROM_DEVICE_ADDR_7BIT;
        send_i2c_command(8'h04, 5);
        #2000;
        
        // --- TEST 2: Write Data to EEPROM ---
        $display("[%t] TEST 2: Sending I2C Write command (0x05) to EEPROM address 0x%h...", $time, WRITE_ADDR);
        tb_payload[0] = WRITE_ADDR;
        for (i=0; i<NUM_BYTES_TO_TEST; i=i+1) begin
            tb_payload[i+1] = expected_data[i];
        end
        send_i2c_command(8'h05, NUM_BYTES_TO_TEST + 1);
        
        $display("[%t] Waiting for I2C write to finish and EEPROM's internal write cycle (tWC)...", $time);
        #6_000_000; // Wait for bus transaction and internal EEPROM write
        
        // --- NEW VERIFICATION: Directly inspect EEPROM memory ---
        verify_eeprom_write();

        // --- TEST 3: Read Data from EEPROM (We send the command to ensure the FSM works, but don't check uploaded data) ---
        $display("[%t] TEST 3: Sending I2C Read command (0x06). This test verifies the command is processed without error.", $time);
        tb_payload[0] = WRITE_ADDR;
        tb_payload[1] = NUM_BYTES_TO_TEST[15:8];
        tb_payload[2] = NUM_BYTES_TO_TEST[7:0];
        send_i2c_command(8'h06, 3);

        #500; // Wait long enough for the read transaction to complete on the bus

        $display("[%t] Simulation finished.", $time);
        $finish;
    end

    //================================================================
    // Helper Tasks
    //================================================================

    task send_usb_byte;
        input [7:0] data;
    begin
        @(posedge clk);
        usb_data_in = data;
        usb_data_valid_in = 1'b1;
        @(posedge clk);
        usb_data_valid_in = 1'b0;
        usb_data_in = 8'h00;
        #20;
    end
    endtask

    task send_i2c_command;
        input [7:0] cmd;
        input [15:0] len;
        reg [7:0] checksum;
    begin
        checksum = 0;
        send_usb_byte(8'hAA); send_usb_byte(8'h55);
        send_usb_byte(cmd); checksum = checksum + cmd;
        send_usb_byte(len[15:8]); checksum = checksum + len[15:8];
        send_usb_byte(len[7:0]); checksum = checksum + len[7:0];
        for (i = 0; i < len; i = i + 1) begin
            send_usb_byte(tb_payload[i]);
            checksum = checksum + tb_payload[i];
        end
        send_usb_byte(checksum);
    end
    endtask
    
    // *** NEW verification task ***
    task verify_eeprom_write;
        reg is_match;
        reg [7:0] read_back_data;
    begin
        is_match = 1;
        $display("-----------------------------------------------------");
        $display("--- Verifying EEPROM Write Operation via Direct Memory Access ---");
        for (i = 0; i < NUM_BYTES_TO_TEST; i = i + 1) begin
            // Use Verilog's hierarchical path to look inside the EEPROM model
            read_back_data = u_eeprom.MemoryBlock0[WRITE_ADDR + i];
            if (read_back_data !== expected_data[i]) begin
                is_match = 0;
                $display("MISMATCH at address 0x%h: Wrote 0x%h, but read back 0x%h", WRITE_ADDR + i, expected_data[i], read_back_data);
            end
        end

        if (is_match) begin
            $display("SUCCESS: All bytes written to EEPROM correctly verified!");
        end else begin
            $display("FAILURE: Data written to EEPROM is incorrect.");
        end
        $display("-----------------------------------------------------");
    end
    endtask

endmodule

