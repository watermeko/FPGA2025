# 1-Wire 主机协议说明

## 📡 通信协议格式

所有 1-Wire 命令遵循标准 USB-CDC 通信协议格式：

```
| 帧头(2B) | 功能码(1B) | 数据长度(2B) | 数据体(N) | 校验和(1B) |
| 0xAA55   |    CMD     |  Big-Endian  |  Payload  |  Checksum |
```

---

## 🔧 功能码详细说明

### 1️⃣ **1-Wire 复位 (功能码 0x20)**

**功能描述**：执行 1-Wire 总线复位并检测从机应答脉冲。

**数据格式**：
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 数据体 | 0 | 无数据 |

**时序说明**：
1. 主机拉低总线 480μs
2. 释放总线
3. 等待 60μs
4. 检测从机应答脉冲（低电平）
5. 等待 40μs 恢复

**示例**：
```
发送: AA 55 20 00 00 1F
      ^^^^帧头 ^^功能码 ^^^^长度=0 ^^校验和
响应: 无（或添加应答状态上传功能）
```

**应用场景**：
- 每次通信前初始化总线
- 检测从机是否在线
- 总线错误恢复

---

### 2️⃣ **1-Wire 写字节 (功能码 0x21)**

**功能描述**：向 1-Wire 总线写入一个或多个字节。

**数据格式**：
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 写数据 | N | 要发送的数据字节 (1-255) |

**时序说明**（每个位）：
- **写 0**：拉低总线 60μs
- **写 1**：拉低总线 6μs，然后释放
- **位间隔**：1μs
- **字节顺序**：LSB first（最低位先发）

**示例 1**：写单字节 0xAB
```
发送: AA 55 21 00 01 AB 0E
      ^^^^帧头 ^^功能码 ^^^^长度=1 ^^数据 ^^校验和
响应: 无
```

**示例 2**：写多字节（写入 ROM 命令 0x55 + 8字节地址）
```
发送: AA 55 21 00 09 55 01 23 45 67 89 AB CD EF XX
      ^^^^帧头 ^^功能码 ^^^^长度=9 ^^Skip ROM ^^^^^^^^8字节地址^^^^^^ ^^校验和
响应: 无
```

**应用场景**：
- 发送 ROM 命令（0x55 跳过 ROM, 0xCC 匹配 ROM 等）
- 发送功能命令（如 DS18B20 的温度转换命令 0x44）
- 写入数据到从机寄存器

---

### 3️⃣ **1-Wire 读字节 (功能码 0x22)**

**功能描述**：从 1-Wire 总线读取指定数量的字节。

**数据格式**：
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 读长度 | 0 | 数据长度字段指定读取的字节数 |

**时序说明**（每个位）：
1. 主机拉低总线 6μs
2. 释放总线
3. 等待 9μs 后采样总线电平
4. 继续等待 55μs 完成读时隙

**响应数据格式**：
```
| 帧头(2B) | 数据来源(1B) | 数据长度(2B) | 数据体(N) | 校验和(1B) |
| 0xAA44   |    0x04      |  Big-Endian  | 读取数据  |  Checksum |
```

**示例**：读取 2 字节数据
```
发送: AA 55 22 00 02 25
      ^^^^帧头 ^^功能码 ^^^^长度=2 ^^校验和
响应: AA 44 04 00 02 12 34 YY
      ^^^^上传帧头 ^^1-Wire源 ^^^^长度=2 ^^读取数据 ^^校验和
```

**应用场景**：
- 读取温度传感器数据（DS18B20 读 9 字节暂存器）
- 读取设备 ROM ID（8 字节）
- 读取 EEPROM 内容

---

### 4️⃣ **1-Wire 写读操作 (功能码 0x23)**

**功能描述**：先写入命令/地址，然后读取响应数据。这是最常用的操作模式。

**数据格式**：
| 字段 | 字节数 | 说明 |
|------|--------|------|
| 写长度 | 1 | 要发送的字节数 (0-255) |
| 读长度 | 1 | 要读取的字节数 (0-255) |
| 写数据 | write_len | 要发送的数据 |

**操作流程**：
1. 发送 write_len 个字节到总线
2. 从总线读取 read_len 个字节
3. 将读取的数据上传到 USB

**响应数据格式**：
```
| 帧头(2B) | 数据来源(1B) | 数据长度(2B) | 数据体(N) | 校验和(1B) |
| 0xAA44   |    0x04      |   read_len   | 读取数据  |  Checksum |
```

**示例 1**：DS18B20 读温度（写 1 字节命令，读 9 字节数据）
```
发送: AA 55 13 00 03 01 09 BE XX
      ^^^^帧头 ^^功能码 ^^^^长度=3 ^^写1字节 ^^读9字节 ^^Read Scratchpad命令 ^^校验和
响应: AA 44 04 00 09 [9字节暂存器数据] YY
      ^^^^上传帧头 ^^1-Wire源 ^^^^长度=9 ^^^暂存器内容^^^ ^^校验和
```

**示例 2**：读取 ROM ID（写 1 字节命令，读 8 字节 ID）
```
发送: AA 55 13 00 03 01 08 33 XX
      ^^^^帧头 ^^功能码 ^^^^长度=3 ^^写1字节 ^^读8字节 ^^Read ROM命令 ^^校验和
响应: AA 44 04 00 08 [8字节ROM ID] YY
      ^^^^上传帧头 ^^1-Wire源 ^^^^长度=8 ^^^ROM ID^^^ ^^校验和
```

**示例 3**：只写不读（write_len>0, read_len=0）
```
发送: AA 55 13 00 03 02 00 CC 44 XX
      ^^^^帧头 ^^功能码 ^^^^长度=3 ^^写2字节 ^^读0字节 ^^Skip ROM ^^Convert T ^^校验和
响应: 无（read_len=0，不上传数据）
```

**应用场景**：
- 温度传感器数据采集（最常用）
- 读取设备信息
- EEPROM 读操作（先发地址，再读数据）

---

## 📊 完整操作流程示例

### 场景：读取 DS18B20 温度传感器

#### 步骤 1：总线复位
```
PC → FPGA: AA 55 20 00 00 1F
等待: 600μs (复位完成)
```

#### 步骤 2：跳过 ROM 寻址
```
PC → FPGA: AA 55 21 00 01 CC 31
说明: 0xCC = Skip ROM 命令，跳过地址匹配
```

#### 步骤 3：启动温度转换
```
PC → FPGA: AA 55 21 00 01 44 65
说明: 0x44 = Convert T 命令
等待: 750ms (温度转换时间)
```

#### 步骤 4：再次复位
```
PC → FPGA: AA 55 20 00 00 1F
```

#### 步骤 5：跳过 ROM 并读取温度
```
PC → FPGA: AA 55 23 00 03 01 09 BE 37
说明: 写 0xBE (Read Scratchpad)，读 9 字节
FPGA → PC: AA 44 04 00 09 [T_LSB] [T_MSB] [TH] [TL] [CFG] [RSV] [RSV] [RSV] [CRC] YY
```

#### 步骤 6：解析温度
```
温度值 = (T_MSB << 8) | T_LSB
实际温度 = 温度值 / 16.0 °C
```

---

## ⚙️ 时序参数表

| 参数 | 符号 | 典型值 | 模块中的值 |
|------|------|--------|-----------|
| 复位脉冲低电平时间 | tRSTL | 480μs | 480μs |
| 应答检测窗口 | tPDH | 60μs | 70μs |
| 写 0 低电平时间 | tLOW0 | 60μs | 60μs |
| 写 1 低电平时间 | tLOW1 | 6μs | 6μs |
| 读初始低电平时间 | tLOWR | 6μs | 6μs |
| 读采样时间 | tRDV | 15μs | 9μs |
| 时隙恢复时间 | tREC | 1μs | 1μs |

**注**：时序参数针对 60MHz 系统时钟优化。

---

## 🔍 调试与测试

### 测试命令序列（Python 示例）

```python
import serial

def calc_checksum(data):
    return sum(data) & 0xFF

# 打开串口
ser = serial.Serial('COM3', 115200)

# 1. 复位测试
cmd = [0xAA, 0x55, 0x20, 0x00, 0x00]
cmd.append(calc_checksum(cmd))
ser.write(bytes(cmd))
print("复位命令已发送")

# 2. 写单字节测试
cmd = [0xAA, 0x55, 0x21, 0x00, 0x01, 0xCC]  # Skip ROM
cmd.append(calc_checksum(cmd))
ser.write(bytes(cmd))
print("Skip ROM 命令已发送")

# 3. 读 ROM ID
cmd = [0xAA, 0x55, 0x23, 0x00, 0x03, 0x01, 0x08, 0x33]  # Read ROM
cmd.append(calc_checksum(cmd))
ser.write(bytes(cmd))
print("Read ROM 命令已发送")

# 等待响应
response = ser.read(13)  # 帧头(2) + 源(1) + 长度(2) + 数据(8) + 校验(1)
print(f"接收到: {response.hex()}")
```

---

## ⚠️ 注意事项

1. **上拉电阻**：1-Wire 总线必须连接 4.7kΩ 上拉电阻到 VDD
2. **寄生供电**：如果使用寄生供电模式，需要在温度转换期间强上拉
3. **CRC 校验**：建议在上位机软件中验证 DS18B20 返回数据的 CRC8
4. **多从机**：如果总线上有多个从机，必须使用 ROM 命令进行寻址
5. **时序容差**：模块时序符合标准，但某些从机可能有特殊要求

---

## 📚 相关文档

- **DS18B20 数据手册**：了解温度传感器具体命令
- **1-Wire 协议规范**：Maxim 1-Wire 总线标准
- **USB-CDC 通信协议.md**：了解整体通信框架

---

完成！现在你已经可以使用 1-Wire 主机功能与各种 1-Wire 从机设备通信了。
